title: 浏览器缓存
date: 2017-10-10 20:20:03
author: dam
tags: 缓存
---
# Pragma
`HTTP/1.0` 时的产物，通知客户端不要对该资源读缓存，即每次都向服务器发一次请求。

# Expires
`HTTP/1.0` 时的缓存策略
```
Expires: Thu, 10 Nov 2017 08:45:11 GMT
```
特点：未过期之前不会再次请求资源  
缺点：客户端的时间与服务器的时间不一致，导致缓存判断失败

# Cache-Control
`HTTP/1.1` 中添加的字段，Cache-Control可以带的值：
1. `max-age`：即最大有效时间，如`max-age=2592000`
2. `no-cache`：表示必须先与服务器确认资源是否被更改过(依据If-None-Match和Etag)，然后再决定是否使用本地缓存
3. `s-maxage`：同max-age，但是仅用于共享缓存，如CDN缓存
4. `public`：多用户共享缓存，默认设置
5. `private`：不能够多用户共享，HTTP认证之后，字段会自动转换成private。

特点： `max-age`的时间是相对时间，所以不会被客户端的时间所影响。

# Last-Modified
服务器告知客户端，资源最后一次被修改的时间  
请求头中带有该字段，服务器会将`If-Modified-Since`的值与`Last-Modified`字段进行对比，如果相等，则表示未修改，响应304；反之，则表示修改了，响应200状态码，返回数据。

缺点： 
1. 如果资源的更新不超过1秒，那么该缓存不能被使用。
2. 如果文件是通过服务器动态生成的，那么更新时间永远都是生成时间

# Etag
Etag存储的是文件的特殊标识（一般都是hash生成的）。但比较少用，因为计算Etag需要占用服务器资源
![image](https://camo.githubusercontent.com/3b71c14c562e33952fc734b0a9cafe4cbf506d5c/687474703a2f2f6c68627a696d6f2e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f657461672e706e67)

# vary
表示服务端会以什么基准字段来区分、筛选缓存版本。
`Vary: User-Agent, Accept-Encoding`

# Date 和 Age
帮用户区分其收到的资源是否命中了代理服务器的缓存。  
如果Date与当前时间相差较大，或者多次刷新Date的时间都没有变化，那么就是命中了缓存。  
Age 也是响应报文中的首部字段，它表示该文件在代理服务器中存在的时间（秒），如文件被修改或替换，Age会重新由0开始累计。

# 浏览器行为引起的不同
1. `刷新网页:` 如果缓存没有失效，浏览器会直接使用缓存；反之，则向服务器请求数据
2. `手动刷新(F5):` 浏览器会认为缓存失效，在请求服务器时加上Cache-Control: max-age=0字段，然后询问服务器数据是否更新。
3. `强制刷新(Ctrl + F5):` 浏览器会直接忽略缓存，在请求服务器时加上Cache-Control: no-cache字段，然后重新向服务器拉取文件。

# 移动端的处理
移动端因为网速问题，所以要尽量减少无用的请求次数。  
一般的操作是在文件后面`加上随机字符串`，然后缓存时间设置为`Cache-Control: max-age=31536000`一年。  
这样就不会出现无用的304的请求。  
一旦需要更新资源，就改变文件后面的字符串，实现文件资源更新。

# 总结
1. `Expires`和`Cache-Control`是强制缓存，如果没有过期，则不会发送资源请求。
2. `Last-Modefied`和`Etag`是对比缓存，不管有没有过期，都会发送资源请求。如果没过期，则返回304；如果过期了，则返回资源和`Last-Modefied`和`Etag`信息
3. 判断优先级`Expires` > `Cache-Control` > `Etag` > `Last-Modefined`

# 参考
1. [彻底弄懂HTTP缓存机制及原理](http://www.cnblogs.com/chenqf/p/6386163.html)